## `redis`复习补充

### 1、持久化

由于`redis`直接在内存上进行操作，关机后，数据瞬间丢失，利用持久化解决这问题。

关于`Redis`的持久化，主要就两种。

`AOF`：以追加日志的形式进行持久化，实时的写入数据，不会有数据丢失。

`RDB`: 根据自定义配置的save规则进行持久化，有可能在持久化前，服务器宕机，则数据丢失。

> `AOF`优缺点

优点：数据实时更新，不会产生数据丢失的情况。

缺点：当大量的修改操作时，实时更新对服务器的负载压力比较大，而且日志文件会很多，恢复起来速度比较慢。

> `RDB`优缺点

优点：可根据自定义规则进行持久化，相对容易恢复数据，速度快，是内存快照的模式。

缺点：数据有丢失。

### 2、主存复制

主机不用配置，只要配置从机。

```bash
SLAVEOF 127.0.0.1 6379 # 认主
```

1)slave启动连接成功master会发送一个snyc（同步）命令

2）master接受后，启动后台存盘进程，待修改数据的命令执行完毕后，将整个数据文件到slave完成一次同步。

3）全量复制：第一次从机连接到主机，从机接受到数据文件后，将其加载到内存中。

4）增量复制：连接到以后，主机修改操作后，将新的数据传给从机同步。

5）只要重连一次master一次自动同步将会自动执行。



### 3、哨兵模式

一主两从：

```java
A（master）--- B（slave)   还有哨兵 指向A,B，C，
  ---C  (slave)
```

哨兵会定时向A,B,C发送命令，等待服务器响应，如果A没有响应，断开了，那么多个哨兵可以进行投票，选取出新的主机。



薪火相传：

```java
A(master)----(slave)B(master)----C(slave)
```

其中B既是主机也是从机。B的命令是：slaveEOF A

C的命令是slaveEOF  B；

如果A存在，那么B不能进行数据的修改，如果A宕机了，那么B就可以接管A的位置当主机。如果A再重连，那么当年的雄风依旧不在(不是再是主机，如果要连上，会变为从机)

### redis 击穿、穿透、雪崩

**雪崩**：某一时刻大量数据失效，导致大量请求打到数据库上，数据库压力过大。**解决方案**: 设置过期时间时加上随机时间：time + random()；

**击穿**:某一时刻大量请求某一个失效数据，同样造成大量数据打到数据库上。**解决方案**: 加分布式锁，当前数据如果没有，则加上锁，后面访问到次数据的等待。

**穿透**：通常是恶意用户，访问redis和mysql都没有的数据。**解决方案**：做数据校验或者布隆过滤器。

**数据校验**:通常前端进行数据校验，校验数据是否合理。

**布隆过滤器**：二进制的一个hash，如果数据库中有该数据，则为1，没有则为0，当用户访问到hash值为0时，直接返回。



**双写不一致**：缓存中的数据和数据库中的数据不一致，修改失败会产生。**解决方案：**每次修改时先删缓存再写库，然后写缓存；

### `Redis`为什么可以作为分布式锁

因为Redis是单线程；

### `redis`为什么快

1. 纯内存操作。
2. 单线程，避免了频繁上下文的切换。
3. 采用非阻塞的I/O多路复用机制