## 一条SQL查询语句执行过程

MySQL分为Server层和存储引擎层

**Server层**：连接器、查询缓存、分析器、优化器、执行器

**存储引擎层**：负责数据的存储和提取

### 连接器

负责跟客户端建立连接、获取权限、维持和管理连接

如我们通过navicat客户端连接，完成TCP握手后，**连接器**来验证你的身份，常见的就是输入**用户名**和**密码**，如果正确，**连接器**则在**权限表**中查出你拥有的**权限**；

> 这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限

一般我们使用**长连接**：如果发现MySQL占用**内存上涨过快**，是因为MySQL在执行过程中**临时使用的内存**是管理在**连接对象**里面的我们可以进行重新连接来释放。

### 查询缓存

连接建立后，如果是select语句就会来到查询缓存，他是key-value形式存储在内存中的，如果有直接返回，否则执行后面的阶段。

**大部分是不建议使用的** 

+ 缓存失效非常频繁，如果update，我们就要将相关字段的缓存全部失效，故命中率可能很低，除非是一些静态表建议使用缓存
+ 将参数`query_cache_type`设置成`DEMAND`使用`SQL_CACHE`显示指定缓存
+ MySQL8.0后已废除查询缓存功能

### 分析器

如果没有命中缓存，则来到此处，进行词法和语法的分析，如`SQL syntax`就是**语法错误**

### 优化器

当经过分析器，知道我们要做什么了，我们会进行优化处理，如：

多表查询时

```sql
select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;
```

其有两种执行方式：

+ 根据t1表中c=10的记录的ID值关联到t2表，再判断t2表中d=20的字段
+ 根据t2表中d=20的记录的ID值关联到t1表，再判断t1表中c=10的字段

逻辑一样，但是执行效率可能不一样，我们优化器来进行选择其中一个方案。

### 执行器

通过**分析器**知道干什么，**优化器**怎么干，就来真正的干了

**执行器首先会判断你是否有表的权限**，如果没有返回权限错误；

如果没有索引的执行流程：

1. 调用InnoDB引擎接口取出这个表的第一行，判断值符不符合，符合则存在当前结果集中，否则跳过
2. 调用引擎接口取“下一行”重复逻辑判断，知道表中最后一行
3. 执行器将上述遍历过程满足条件的行组成记录集最为结果集返回给客户端并且存在缓存中

### 小结

1. 连接
   连接管理模块，接收请求；连接进程和用户模块，通过，连接线程和客户端对接
2. 查询
   查询缓存 Query Cache
   **分析器**，内建解析树，对其语法检查，先from，再on，再join，再where......；检查权限，生成新的解析树，语义检查（没有字段k在这里）等
   **优化器**，将前面解析树转换成执行计划，并进行评估最优
   **执行器**，获取锁，打开表，通过meta数据，获取数据
3. 返回结果
   返回给连接进程和用户模块，然后清理，重新等待新的请求

## 一条SQL更新语句执行过程

### redo log

当更新时，InnoDB引擎会先记录在redo log中，并更新内存，等InnoDB空闲时，会将记录更新在磁盘里

InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么总共就可以记录4GB的操作，是一个循环写入的模式。

![image-20200727194525733](https://cdn.jsdelivr.net/gh/cheerfulman/PigGo-img/img/20200804132946.jpg)

**write pos** : 当前记录的位置，一边写一边后移。

**check point** : 当前要擦除的位置

其**write pos**和**check point**中间的位置即为空着的部分，有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为**crash-safe**。

### binglog

binglog主要是归档日志，以追加的形式，记录正常更新到磁盘中的操作。

> redo log 和 binglog不同

1. binglog 为Server层的日志，所有引擎都有，而redo log是InnoDB特有的
2. redo log是物理日志，记录“在某个数据页上做了什么修改”；binglog是逻辑日志，比如“给ID=2这一行的c字段加1 ”。
3. redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

**update语句流程**

1. 执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的binlog，并把binlog写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。

![image-20200727195826486](https://cdn.jsdelivr.net/gh/cheerfulman/PigGo-img/img/20200804132848.png)

### 两阶段提交

**1** prepare阶段 **2** 写binlog **3** commit
当在2之前崩溃时
重启恢复：后发现没有commit，回滚。备份恢复：没有binlog 。**一致**

当在3之前崩溃
重启恢复：虽没有commit，但满足prepare和binlog完整，所以重启后会自动commit。备份：有binlog. **一致**

