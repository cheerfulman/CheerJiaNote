## 数据库原理

比如点赞收藏一篇文章，我要对该文章的权重值进行一个增加（增大其流量曝光率，优先显示该文章），**所以我们进行点赞收藏，数据库对齐点赞数，收藏数进行累加的同时，我们对权重值也要增加。** 也就是说，它们是一起的，如果有异常，我们对其点了赞，赞数已经写到数据库后怕抛出了异常，但是权重值没有增加怎么办?

所以我们需要引入事务！

> 什么是事务呢？

### 1 事务(Transaction)

一般指计算机想做的事情，一个程序执行的单位。由事务开始到事务结束之间的全体操作组成。满足ACID的一组操作。

### 2 ACID

1. 原子性 : 事务是一个不可分割的整体。要么全部成功，要么全部失败。
2. 一致性 : 事务在执行前后都保持一致性，也就是说，所有事务，对同一个数据读取的结果是一样的。
3. 隔离性 : 事务之间，互不影响。（事务执行之前，对其它事务是不可见的）
4. 持久性 : 提交到数据库中之后，永久存在，事务执行的结果不丢失。

### 3 并发一致性的问题

> 并发与隔离不可兼得？

> 引发四大问题！

+ **丢失修改**：事务A对data 进行修改，事务B对data也进行了修改，那么就会覆盖A的修改。

+ **读脏数据**（脏读）：事务A修改了data然后事务B读取了data，接着事务A出现问题，回滚了事务，那么B读取的就是脏数据。也就是说**事务A还未提交，B就已经读了。**
+ **不可重复读**：在一个事务中进行了多次读取，发现结果不一致。
+ **幻读**：事务A进行了一个读取发现不存在，随后事务B插入了一条数据，事务A又读到了，就像幻觉一样。

既然有这四大问题，我们就要采取措施。

### 4 封锁

MySQL中提供了两种封锁粒度： 行级锁（对行进行封锁） 和 表级锁（对整张表）

### 5 封锁类型

#### 1. 读写锁

+ 互斥锁 :  也叫x锁，就是写锁。
+ 共享锁 : 也叫 S锁，就是读锁。

两个规定：

+ 一个事务在写的时候加X锁，可以对数据进行读和写，其它事务都不能加锁。
+ 一个事务在读一个数据时加S锁，其它事务可以加S锁。但是不可以加X锁（写锁）

#### 三级封锁类型

+ 一级封锁类型：事务对数据进行修改时要加上写锁(X锁)，**解决丢失修改问题**

+ 二级封锁类型：在一级的基础上，在读的时候要加上S锁（读锁），读完之后，马上释放S锁。**解决了脏读的问题**
+ 三级封锁类型：在二级的基础上，我要等事务结束才释放S锁。可以**解决不可重复读的问题**；

> 为了解决并发事务的问题，就有了隔离级别

### 6 隔离级别

1. 未提交读 : 解决**丢失修改**的问题，如果事务读，其它就不能写，没有加S锁，事务未提交，别人就能读，**故有脏读问题。**
2. 提交读 : 可以解决脏读问题，加了行级的锁，读完之后，释放锁。有**不可重复读**的问题。（由于读完后马上释放锁，其它事务可以修改，再读取的时候数据不一致）
3. 可重复读 ： 相当于事务锁，读完之后，事务结束才释放锁，**不会产生重复读取数据不一致的现象**但是会出现**幻读**问题
4. 串行化 : 事务序列化执行，毫无并发可言，效率低下。解决了**幻读**问题。



在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准:

+ 读未提交：没有视图概念，直接返回记录上的最新值
+ 读提交：每个`SQL`语句开始执行时创建
+ 可重复读：启动事务时创建
+ 串行化：直接加锁避免并行访问