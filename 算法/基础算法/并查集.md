## leetcode1202

给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。

你可以 任意多次交换 在 pairs 中任意一对索引处的字符。

返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。

**示例 1**:

```txt
输入：s = "dcab", pairs = [[0,3],[1,2]]
输出："bacd"
解释： 
交换 s[0] 和 s[3], s = "bcad"
交换 s[1] 和 s[2], s = "bacd"
```

**示例 2**：

```txt
输入：s = "dcab", pairs = [[0,3],[1,2],[0,2]]
输出："abcd"
解释：
交换 s[0] 和 s[3], s = "bcad"
交换 s[0] 和 s[2], s = "acbd"
交换 s[1] 和 s[2], s = "abcd"
```

**示例 3**：

```txt
输入：s = "cba", pairs = [[0,1],[1,2]]
输出："abc"
解释：
交换 s[0] 和 s[1], s = "bca"
交换 s[1] 和 s[2], s = "bac"
交换 s[0] 和 s[1], s = "abc"
```

> 我们发现 [[0,3],[1,2],[0,2]] 0和3可以交换，1,2可以交换，0和2可以交换
>
> 那么2既可以和1交换也可以和0交换，所以0,1,2可相互交换不限次数
>
> 故我们发现这是一个并查集的问题，如果在一个集合中，则可以无限交换。
>
> 一个集合中我们要按字典序从小到大排序，也就是索引为0下标的集合，我们肯定要输出集合中字典序最小的，这样就可以用到优先队列排序，将相同集合的元素加入优先队列。

```java
public class LeetCode1202 {
    List<Integer> f;
    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {
        f = new ArrayList<>();
        int n = s.length();
        // 初始化并查集根元素
        for(int i = 0; i < n; i ++) f.add(i);
        // 将其可替换的下标合并 --- 构建并查集
        for(List<Integer> list : pairs){
            int a = find(list.get(0)), b = find(list.get(1));
            if(a != b) f.set(a,b);
        }
        // 用map 保存根相同的元素，存入优先队列，这样省去排序的步骤
        // 将来将同一根下的字符，按照字典序pop即可
        Map<Integer, PriorityQueue<Character>> map = new HashMap<>();
        // 将所有字符入优先队列
        for(int i = 0; i < n; i ++){
            int cur = find(i);
            char ch = s.charAt(i);
            if(!map.containsKey(cur)) {
                map.put(cur,new PriorityQueue<>());
            }
            map.get(cur).offer(ch);
        }
        StringBuffer sb = new StringBuffer();
        // 按照字典序大小输出
        for(int i = 0; i < n; i ++){
            sb.append(map.get(find(i)).poll());
        }
        return sb.toString();

    }

    private int find(int x){
        if(f.get(x) != x)
            f.set(x,find(f.get(x)));
        return x;
    }
}
```



