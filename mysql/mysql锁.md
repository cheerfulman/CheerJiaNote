## MySQL锁

### 全局锁

全局锁：对整个数据库实例加锁，命令：Flush tables with read lock(FTWRL)，让整个库处于只读的状态。

**一般使用全局锁的场景是做全库的逻辑备份**；

- 如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；
- 如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。

如果不加锁的话，肯定又会出问题，比如某个人买了个商品，先扣减他的余额表，再增加商品，那么就有可能备份到他扣了钱，但是商品没增加，也就是说用户钱白白少了；

这里我们可以看到，原因在于他们不在一个逻辑时间点，这个视图是逻辑不一致的。说到这我们想到了事务隔离时，用视图保持一致。就是在可重复读隔离级别下开启一个事务。

那么我们官方也自带一个逻辑备份工具：**mysqldump**,使用**-single-trasaction**时导数据前会启动一个事务来确保拿到一致性视图。(MVCC的支持，故这个过程中数据是可以正常更新的)

但是要使用这个-single-trasaction的前提是引擎要支持这个隔离级别(rr);如果该引擎不支持事务隔离级别则只能使用**FTWRL**;

>  既然要使全库只能读，为什么不使用set global readonly = true呢？

+ readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。
+ 在异常处理机制上有差异。如果执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库就会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高。
+ 在 slave 上 如果用户有超级权限的话 readonly 是失效的（readonly 对 super 权限无效）

### 表级锁

MySQL中有两种表级锁：**表锁**和**元数据锁**(meta data lock，MDL);

**表锁语法 --- lock tables ... read/write**,可以使用unlock tables主动释放锁；

举个例子, 如果在某个线程A中执行lock tables t1 read, t2 write; 这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行unlock tables之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。

**元数据锁(MDL)**:不需要显示调用，在访问一个表时会被自动加上，MDL的的作用是，保证读写的正确性。如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上。MDL就是可以解决这个问题的。

因此在MySQL5.5之后加入了MDL，当进行增删改数据（DML)时加写锁，加字段等修改表结构的操作（DDL）加读锁；

+ 读锁不互斥
+ 读写锁，写写锁互斥

MDL会自动加锁，也会引出下面一个问题：

**首先给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。**所以在操作大表时要小心，给小表加字段时也不能忽略；

> 备注：这里的实验环境是MySQL 5.6。

![img](https://static001.geekbang.org/resource/image/7c/ce/7cf6a3bf90d72d1f0fc156ececdfb0ce.jpg)

我们看到，sessionA启动加了读锁，B也加读锁可以执行，但是C要加写锁---阻塞，但是D以及D以后的DML操作都会被阻塞。

**事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。**

如果A、B马上提交了，释放了锁不就不会出现上述问题了吗？

>  要解决这个问题，首先就要讨论解决长事务，

我们可以在MySQL的**information_schema** 库的 **innodb_trx** 表中查询长事务；如果要执行DDL，可以先kill掉这个事务；

>  但如果**这是个热点数据**呢？

alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者DBA再通过重试命令重复这个过程。

MariaDB已经合并了AliSQL的这个功能，所以这两个开源分支目前都支持DDL NOWAIT/WAIT n这个语法。

```
ALTER TABLE tbl_name NOWAIT add column ...
ALTER TABLE tbl_name WAIT N add column ... 
```

### 行级锁

首先MyISAM引擎就不支持行锁，行锁的粒度当然更小；

#### 两阶段锁

事务B的update语句执行时会是什么现象呢？假设字段id是表t的主键。
![img](https://static001.geekbang.org/resource/image/51/10/51f501f718e420244b0a2ec2ce858710.jpg)

事务B的update会阻塞，知道事务Acommit之后；

**在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。**

所以如果当我们两个事务可能会出现锁冲突时，我们可以尽可能的把它放到后面执行，比如：

顾客A 去 B买电影票：

1. A扣钱
2. B增加钱
3. 记录日志

而当C也去B电影院买票的话，两个事务就会在**B增加钱**上有冲突，那么我们就可以把顺序改位132；那么**B加钱**行锁时间就最少了，事务提交就释放了；

虽然这么做可以减少锁的时间，但是在某些情况下（用户量大最活动时），还是会有死锁的发生；

#### 死锁和死锁检测

当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。这里我用数据库中的行锁举个例子。
![img](https://static001.geekbang.org/resource/image/4d/52/4d0eeec7b136371b79248a0aed005a52.jpg)当出现死锁时，一般有两种策略：

+ 直接进入等待，直到超时。这个超时时间可以通过参数`innodb_lock_wait_timeout`来设置
+ 死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数`innodb_deadlock_detect`设置为`on`，表示开启这个逻辑。

在InnoDB中，innodb_lock_wait_timeout的默认值是50s，这个时间太长了，但是太短也不行，会误杀很多执行时间稍长事务；

一般采取第二种方式：主动进行死锁检测 --- **当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。**

当大量事务都修改某一行时，如果要判断自己的加入会不会导致死锁，进行检测是需要消耗大量cpu资源的；

> 如何解决由这种热点行更新导致的性能问题呢？

+ **可以临时把死锁检测关掉**（有风险）
+ **控制并发度**
  + ：如有10个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。但是如果客户端很多，也一样，所以控制并发要做在服务端可以考虑在中间件实现
+ **将一行改成逻辑上的多行来减少锁冲突**
  + 比如10个记录，影院的账户总额等于这10个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的1/10，可以减少锁等待个数，也就减少了死锁检测的CPU消耗。
  + 这个方案看上去是无损的，但其实这类方案需要根据业务逻辑做详细设计。如果账户余额可能会减少，比如退票逻辑，那么这时候就需要考虑当一部分行记录变成0的时候，代码要有特殊处理。

### 小结

+ 在逻辑备份时如果是innoDB引擎，可以使用–single-transaction参数

+ 表锁一般是在数据库引擎不支持行锁的时候才会被用到的。

+ MDL会在事务提交才释放，做表结构变更时要注意锁住线上查询和更新。问题

+ 如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁的申请时机尽量往后放。

  

